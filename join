#! /usr/bin/env python3

#The incantation for making a Python script executable under WinNT is to give the file an extension of .cmd and add the following as the first line:

#@setlocal enableextensions & python -x %~f0 %* & goto :EOF
#cmd shebang needs quotes for "%~f0"

from sys import (argv, stdout, stderr)
import csv
from collections import (namedtuple, defaultdict)
from xml.sax import saxutils
from tkinter.tix import Tk
from tkinter.ttk import (Button, Entry, Frame, Label, LabelFrame,
    Checkbutton)
import tkinter
from functools import partial
from tkinter import (StringVar, DoubleVar, Toplevel)
from tkinter.tix import FileEntry
from lib.tk import ScrolledTree
from lib.tk import Form

def main():
    help = False
    grid = 0o000
    area = []
    plants = []
    freq_thold = THOLD_DEFAULT
    ca_file = None
    freq_file = None
    evcs = []
    quads = []
    
    i = iter(argv)
    next(i)
    while True:
        try:
            arg = next(i)
        except StopIteration:
            break
        
        lower = arg.lower()
        if lower in {"help", "-h", "--help", "-?", "?"}:
            help = True
        elif lower == "grid":
            grid |= int(next(i), 8)
        elif lower == "area":
            area.extend(next(i))
        elif lower == "ca":
            ca_file = next(i)
        elif lower == "freqs":
            freq_file = next(i)
        elif lower == "evc":
            evcs.append(next(i))
        elif lower == "quad":
            quads.append(next(i))
        elif lower == "thold":
            freq_thold = float(next(i))
        else:
            raise SystemExit('''\
Bad command line argument: {}
Try "{} help"'''.format(arg, argv[0]))
    
    if help:
        print("""\
join ca ... [area ...] [freqs ... evc ...] [quad ...] [options] > output.html
\tIncludes only those plants selected by the "area", "evc" and "quad"
\toptions. Ignores plants with * and + origin, and ferns, orchids and
\tmistletoes.

Options:
ca <{CA_DEFAULT}>
\tCastlemaine plant list CSV file. Produce combined list based off this.
freqs <{FREQ_DEFAULT}>
\tEVC frequency plant list CSV file
grid <octal code>
\tOctal (binary) mask code of 10-minute grid references to highlight. The
\tmatching grid code(s) are indicated in the list, but this does not
\taffect whether a plant is selected in the list. A single grid code
\thighlights plants in the corresponding grid area, independent of whether
\tthey are also in any other grid areas. Multiple grid options means to
\thighlight which of the provided grids a plants is from. 
area <alphanumeric sequence>
\tCastlemaine plant list area codes to include. More than one may be
\tspecified as a string of codes or multiple options. The order does not
\tmatter. The matching codes are indicated in the list.
evc <name or number>
\tInclude plants whose relative frequencies in EVC exceed threshold. Use
\t"freqs" option alone to list EVCs. If the EVC does not exist (or is
\tspelt wrong), the only indication is the corresponding output column is
\tnot populated.
quad <Viridans CSV file>
\tInclude plants from Viridans quadrat. The "systematic format" is
\tprobably better than the alphabetical because some types of plants are
\tthen easily identified by the program and ignored.
thold <threshold>
\tEVC frequency threshold (default: {THOLD_DEFAULT})
help\tDisplay this help""".format(**locals()))
        return
    
    if ca_file is None and freq_file is None and not quads:
        Ui(grid=grid, area=area, evcs=evcs, freq_thold=freq_thold)
    else:
        join(
            ca_file=ca_file, grid=grid, area=area,
            freq_file=freq_file, evcs=evcs, freq_thold=freq_thold,
            quads=quads,
        )

class Ui(object):
    def __init__(self, grid, area, evcs, freq_thold):
        self.root = Tk()
        self.root.title("Reveg DB")
        
        frame = LabelFrame(self.root, text="Castlemaine plant list")
        frame.grid(columnspan=2, sticky=tkinter.EW)
        form = Form(frame)
        self.ca_file = add_file(form, CA_DEFAULT, text="Source file")
        
        self.grid = StringVar(value="{:03o}".format(grid))
        field = Frame(frame)
        entry = Entry(field, textvariable=self.grid, validate="key",
            validatecommand=ValidateCommand(self.root, self.validate_grid))
        entry.pack(side=tkinter.LEFT, expand=True, fill=tkinter.X)
        grid_button = partial(grid_menu, self.grid, field)
        grid_button = Button(field, text="Menu . . .", command=grid_button)
        grid_button.pack(side=tkinter.LEFT)
        form.add_field(field, text="Highlight grid sections")
        
        self.area = StringVar(value="".join(area))
        entry = Entry(frame, textvariable=self.area)
        form.add_field(entry, text="Select areas")
        
        self.freqs = Freqs(self.root, evcs=evcs, thold=freq_thold)
        self.quads = Quads(self.root)
        
        self.out_file = StringVar(value="join.html")
        form = Form(self.root)
        entry = FileEntry(self.root, dialogtype="tk_getSaveFile",
            variable=self.out_file)
        form.add_field(entry, text="Output file")
        button = Checkbutton(self.root, text="Include common names")
        button.grid(column=1, sticky=tkinter.W)
        
        button = Button(self.root, text="Produce list . . .",
            command=self.join)
        button.grid(columnspan=2)
        self.root.bind("<Return>", self.join)
        
        self.root.mainloop()
    
    def join(self):
        return join(
            ca_file=self.ca_file.get(),
            grid=int(self.grid.get(), 8),
            area=self.area.get(),
            freq_file=self.freqs.file.get(),
            evcs=self.freqs.get_evcs(),
            freq_thold=self.freqs.thold.get(),
            quads=self.quads.get(),
        )
    
    def validate_grid(self, value):
        if not value:
            return True
        
        try:
            value = int(value, 8)
        except ValueError as err:
            print(err, file=stderr)
            return False
        
        return 0 <= value < 0o1000

FREQ_DEFAULT = "GoldfieldsBrgnlEVCSppFreq.xls.csv"
CA_DEFAULT = "PLANT_CA.TXT"
THOLD_DEFAULT = 0.3

class grid_menu(Toplevel):
    def __init__(self, grid, master):
        self.var = grid
        
        Toplevel.__init__(self, master)
        self.title("Grid sections")
        self.bind("<Return>", self.destroy)
        self.bind("<Escape>", self.destroy)
        
        Entry(self, textvariable=self.var).pack(fill=tkinter.X)
        
        frame = Frame(self)
        self.buttons = list()
        for column in range(3):
            frame.columnconfigure(column, weight=1)
        
        for row in range(3):
            frame.rowconfigure(row, weight=1)
            
            buttons = list()
            for (column, name) in enumerate(self.names[row]):
                command = partial(self.update_var, row, column)
                button = Checkbutton(frame, command=command, text=name)
                button.grid(row=row, column=column, sticky=tkinter.NSEW)
                
                if not int(self.focus_lastfor()["takefocus"]):
                    button.focus_set()
                buttons.append(button)
            self.buttons.append(buttons)
        
        frame.pack(fill=tkinter.BOTH, expand=True)
        
        self.var_cb = self.var.trace_variable("w", self.update_buttons)
        self.update_buttons()
        
        button = Button(self, text="Close", command=self.destroy, default="active")
        button.pack(side=tkinter.BOTTOM)
    
    names = (
        ("M46", "M47", "M48"),
        ("N1", "N2", "N3"),
        ("N10", "N11", "N12"),
    )
    
    def update_var(self, row, column):
        current = int(self.var.get(), 8)
        value = 0o100 << row >> (column * 3)
        button = self.buttons[row][column]
        if button.instate(("selected",)):
            current |= value
        else:
            current &= ~value
        self.var.set("{:03o}".format(current))
    
    def destroy(self, *_):
        self.var.trace_vdelete("w", self.var_cb)
        return Toplevel.destroy(self)
    
    def update_buttons(self, *_):
        value = int(self.var.get(), 8)
        for (row, buttons) in enumerate(self.buttons):
            for (column, button) in enumerate(buttons):
                if value & 0o100 << row >> (column * 3):
                    button.state(("selected",))
                else:
                    button.state(("!selected",))

class Quads(object):
    def __init__(self, root):
        frame = LabelFrame(root, text="Viridans quadrats")
        frame.grid(columnspan=2, sticky=(tkinter.EW, tkinter.NS))
        form = Form(frame)
        root.rowconfigure(frame.grid_info()["row"], weight=1)
        
        self.file = StringVar()
        entry = FileEntry(frame, dialogtype="tk_getOpenFile",
            variable=self.file)
        form.add_field(entry, text="Source file")
        
        buttons = Frame(frame)
        button = Button(buttons, text="Add", command=self.add)
        button.pack(side=tkinter.LEFT, expand=True)
        button = Button(buttons, text="Remove", command=self.remove)
        button.pack(side=tkinter.LEFT, expand=True)
        buttons.grid(columnspan=2, sticky=tkinter.EW)
        
        self.list = ScrolledTree(frame)
        self.list.grid(columnspan=2, sticky=tkinter.NSEW)
        frame.rowconfigure(self.list.grid_info()["row"], weight=1)
        self.list.bind_select(self.select)
    
    def add(self):
        item = self.list.add(text=self.file.get())
        self.list.tree.focus(item)
        self.list.tree.selection_set(item)
        
        # Apparently needed when calling Treeview.see() straight after adding
        # an item
        self.list.update_idletasks()
        
        self.list.tree.see(item)
    
    def select(self, *_):
        (item,) = self.list.tree.selection()
        self.file.set(self.list.tree.item(item, option="text"))
    
    def remove(self):
        # Empty selection returns empty string?!
        items = tuple(self.list.tree.selection())
        
        focus = self.list.tree.focus()
        refocus = focus in items
        if refocus:
            new = focus
            while new in items:
                new = self.list.tree.next(new)
            if not new:
                new = focus
                while new in items:
                    new = self.list.tree.prev(new)
            if not new:
                refocus = False
        
        self.list.tree.delete(*items)
        
        if refocus:
            self.list.tree.focus(new)
    
    def get(self):
        quads = list()
        for item in self.list.tree.get_children():
            quads.append(self.list.tree.item(item, option="text"))
        return quads

def join(ca_file, grid, area, freq_file, evcs, freq_thold, quads):
        class Plant(Record):
            def __init__(self):
                Record.__init__(self,
                    ca=None,
                    evcs=dict(),
                    quads=dict(),
                )
        plants = defaultdict(Plant)
        
        if ca_file is not None:
            CaPlant = namedtuple("CaPlant",
                "name, ex, common, family, fam_com, group, area, grid, note")
            with open(ca_file, newline="") as file:
                for plant in csv.reader(file):
                    if plant[0].startswith("\x1A"):
                        break
                    
                    plant = CaPlant._make(plant)
                    
                    if (not plant.grid or plant.ex in tuple("*+") or
                    plant.group == "f" or
                    plant.family in ("Orchidaceae", "Loranthaceae")):
                        continue
                    
                    plants[plant.name].ca = plant
        
        if freq_file is not None:
            DIV_FERN = "2"
            DIV_MOSS = "5"
            FAM_MISTLETOE = "124"
            FAM_ORCHID = "124"
            
            max_freq = dict()
            
            with open(freq_file, newline="") as file:
                for plant in csv.DictReader(file):
                    for key in EVC_KEYS:
                        evc = plant[key]
                        if evc not in evcs:
                            continue
                        
                        freq = int(plant["Frequency"])
                        try:
                            max = max_freq[evc]
                        except LookupError:
                            max_freq[evc] = freq
                        else:
                            if freq > max:
                                max_freq[evc] = freq
                        
                        if (plant["ORIGIN"] == "*" or
                        plant["DIVISION"] in (DIV_FERN, DIV_MOSS) or
                        plant["FAMILYNO"] in (FAM_ORCHID, FAM_MISTLETOE)):
                            continue
                        
                        plant["Frequency"] = freq
                        plants[plant["NAME"]].evcs[evc] = plant
        
        ViridansPlant = namedtuple("ViridansPlant",
            "arots, vrots, origin, name, common")
        for quad_file in quads:
            with open(quad_file, newline="") as file:
                file = csv.reader(file)
                next(file)
                group = None
                family = None
                for row in file:
                    if row[1] == "t1":
                        (group, _, *_) = row
                        family = None
                        continue
                    elif row[1] == "t2":
                        (family, _, *_) = row
                        continue
                    
                    if (group == "6: Ferns and Fern-like Plants" or
                    family in ("Orchidaceae", "Loranthaceae")):
                        continue
                    
                    plant = ViridansPlant._make(row)
                    if plant.origin == "*":
                        continue
                    
                    plants[plant.name].quads[quad_file] = plant
        
        print("<html><body><table>")
        print("<tr><th>name</th><th>ex</th><th>area</th><th>grid</th>")
        print_tagged("th", evcs)
        print_tagged("th", quads)
        print("</tr>")
        
        for name in sorted(plants.keys()):
            plant = plants[name]
            
            if plant.ca is None:
                plant_ex = ""
                plant_area = ""
                plant_grid = ""
            else:
                plant_ex = plant.ca.ex
                plant_area = "".join(a for a in plant.ca.area if a in area)
                plant_grid = "{:03o}".format(int(plant.ca.grid, 8) & grid)
            
            rel = list()
            thold_met = False
            for evc in evcs:
                try:
                    evc_plant = plant.evcs[evc]
                except LookupError:
                    rel.append("")
                else:
                    freq = evc_plant["Frequency"] / max_freq[evc]
                    thold_met = thold_met or freq >= freq_thold
                    rel.append("{:.2f}".format(freq))
            
            inquads = tuple(quad in plant.quads for quad in quads)
            
            if not plant_area and not thold_met and not any(inquads):
                continue
            
            print("<tr>")
            print_tagged("td", (name, plant_ex, plant_area, plant_grid))
            print_tagged("td", rel)
            print_tagged("td", ("Y" if q else "" for q in inquads))
            print("</tr>")
        
        print("</table></body></html>")

def print_tagged(tag, list):
    for text in list:
        print("<{tag}>{}</{tag}>".format(saxutils.escape(text), tag=tag))

EVC_KEYS = ("EVC_DESC", "EVC")

class Freqs(object):
    def __init__(self, root, evcs, thold):
        frame = LabelFrame(root, text="EVC frequencies")
        frame.grid(columnspan=2, sticky=(tkinter.EW, tkinter.NS))
        form = Form(frame)
        root.rowconfigure(frame.grid_info()["row"], weight=1)
        
        self.file = add_file(form, FREQ_DEFAULT, text="Source file")
        
        self.saved_evcs = evcs
        self.evc_list = ScrolledTree(frame, columns=2)
        form.add_field(self.evc_list, text="Select EVCs", multiline=True)
        self.select_binding = self.evc_list.bind_select(self.select)
        
        self.file.trace("w", self.update)
        
        self.thold = DoubleVar(value=thold)
        entry = Entry(frame, textvariable=self.thold, validate="key",
            validatecommand=ValidateCommand(root, self.validate_thold))
        form.add_field(entry, text="Frequency threshold")
    
    def update(self, *_):
        self.evc_list.tree.delete(*self.evc_list.tree.get_children())
        if not self.file.get():
            return
        with open(self.file.get(), newline="") as file:
            evcs = set(tuple(row[key] for key in EVC_KEYS)
                for row in csv.DictReader(file))
        
        selection = list()
        for evc in sorted(evcs):
            (name, number) = evc
            item = self.evc_list.add(text=name, values=(number,))
            if any(value in self.saved_evcs for value in evc):
                selection.append(item)
        
        if selection:
            self.evc_list.unbind_select(self.select_binding)
            self.evc_list.tree.focus(selection[0])
            self.evc_list.tree.selection_set(tuple(selection))
            
            # Treeview.see() straight after adding items does not seem to
            # work without at least update_idletasks(), and the <<Treeview
            # Select>> event does not seem to be handled until update() is
            # called.
            self.evc_list.update()
            
            self.evc_list.tree.see(selection[-1])
            self.evc_list.tree.see(selection[0])
            
            self.select_binding = self.evc_list.bind_select(self.select)
    
    def select(self, event):
        self.saved_evcs = list()
        for item in self.evc_list.tree.selection():
            name = self.evc_list.tree.item(item, option="text")
            self.saved_evcs.append(name)
            number = self.evc_list.tree.item(item, option="values")
            self.saved_evcs.extend(number)
    
    def get_evcs(self):
        evcs = list()
        for item in self.evc_list.tree.selection():
            evcs.append(self.evc_list.tree.item(item, option="text"))
        return evcs
    
    def validate_thold(self, value):
        if not value:
            return True
        
        try:
            value = DoubleVar(value=value).get()
        except ValueError as err:
            print(err, file=stderr)
            return False
        
        return 0 <= value <= 1

def add_file(form, default, **kw):
    field = Frame(form.master)
    file = StringVar(value=default)
    FileEntry(field, dialogtype="tk_getOpenFile", variable=file).pack(
        side=tkinter.LEFT, expand=True, fill=tkinter.X)
    Button(field, text="Delete", command=partial(file.set, "")).pack(
        side=tkinter.LEFT)
    form.add_field(field, **kw)
    return file

def ValidateCommand(tk, func):
    """Help get the new value for input validation
    
    Hinted by Michael Lange, "Validating an entry":
    http://mail.python.org/pipermail/tkinter-discuss/2006-August/000863.html
    """
    
    return (tk.register(func), "%P")

class Record(object):
    def __init__(self, *args, **kw):
        self.__dict__.update(*args, **kw)

if __name__ == "__main__":
    main()

#Grid alias incl cmd line
#Fuzzy text matching
#@Ern: Some plants are abbreviated, minor problems worked around; eg:
# Lomandra longifolia ssp longifol.
# Dianella aff longifolia 'Benambra
# Lomandra multiflora ssp multiflor
#How to handle origin, exotic, AROTS, VROTS merging or multiple columns
#How to do Windows python scripts so they are easy to run
#Case-insensitive evc names
#Explicit option to list evcs
#what if evc not found?
